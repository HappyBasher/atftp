Description: Fix sorcerer's apprentice bug
Origin: https://www.freesoft.org/CIE/RFC/1123/77.htm
Bug-Debian: https://bugs.debian.org/275056
Forwarded: https://sourceforge.net/p/atftp/support-requests/9/

--- a/atftp.1
+++ b/atftp.1
@@ -88,6 +88,14 @@
 See atftpd's man page.
 
 .TP
+.B \-\-prevent\-sas
+Address the Sorcerer's Apprentice Syndrome situation as requested by RFC 1350.
+This RFC requires repeated responses to a single packet to be
+rejected. Thus a block will only get retransmitted on a timeout.
+For backward compatibility, the default stays to ignore this RFC.
+So blocks get transmitted on every request.
+
+.TP
 .B \-\-verbose
 Instruct atftp to be verbose. It will print more information about
 what's going on.
--- a/atftpd.8
+++ b/atftpd.8
@@ -181,6 +181,14 @@
 option has effect only for non-multicast transfer.
 
 .TP
+.B \-\-prevent\-sas
+Address the Sorcerer's Apprentice Syndrome situation as requested by RFC 1350.
+This RFC requires repeated responses to a single packet to be
+rejected. Thus a block will only get retransmitted on a timeout.
+For backward compatibility, the default stays to ignore this RFC.
+So blocks get transmitted on every request.
+
+.TP
 .B \-\-mcast\-switch\-client
 This option allow the server to proceed with the next multicast client
 as soon as the current client timeout. When the current master client
--- a/tftp.c
+++ b/tftp.c
@@ -58,6 +58,7 @@
 /* defined as extern in tftp_file.c and mtftp_file.c, set by the signal
    handler */
 int tftp_cancel = 0;
+int tftp_prevent_sas = 0;
 
 /* local flags */
 int interactive = 1;            /* if false, we run in batch mode */
@@ -1006,6 +1007,7 @@
 #endif
           { "mtftp", 1, NULL, '1'},
           { "no-source-port-checking", 0, NULL, '0'},
+          { "prevent-sas", 0, NULL, 'X'},
           { "verbose", 0, NULL, 'v'},
           { "trace", 0, NULL, 'd'},
 #if DEBUG
@@ -1115,6 +1117,9 @@
           case '0':
                data.checkport = 0;
                break;
+          case 'X':
+               tftp_prevent_sas = 1;
+               break;
           case 'v':
                snprintf(string, sizeof(string), "verbose on");
                make_arg(string, &ac, &av);
@@ -1226,6 +1231,7 @@
              "  --mtftp <\"name value\">   : set mtftp variable to value\n"
 #endif
              "  --no-source-port-checking: violate RFC, see man page\n"
+             "  --prevent-sas            : prevent Sorcerer's Apprentice Syndrome\n"
              "  --verbose                : set verbose mode on\n"
              "  --trace                  : set trace mode on\n"
 #if DEBUG
--- a/tftp_file.c
+++ b/tftp_file.c
@@ -49,6 +49,7 @@
 #define NB_BLOCK        2048
 
 extern int tftp_cancel;
+extern int tftp_prevent_sas;
 
 /*
  * Find a hole in the file bitmap.
@@ -629,6 +630,7 @@
      int timeout_state = state; /* what state should we go on when timeout */
      int result;
      long block_number = 0;
+     long last_requested_block = -1;
      long last_block = -1;
      int data_size;             /* size of data received */
      int sockfd = data->sockfd; /* just to simplify calls */
@@ -791,6 +793,18 @@
                     }
 		    block_number = tftp_rollover_blocknumber(
 			ntohs(tftphdr->th_block), prev_block_number, 0);
+
+                    /* if turned on, check whether the block request isn't already fulfilled */
+                    if (tftp_prevent_sas) {
+                         if (last_requested_block >= block_number) {
+                              if (data->trace)
+                                   fprintf(stderr, "received duplicated ACK <block: %ld >= %ld>\n",
+                                           last_requested_block, block_number);
+                              break;
+                         } else
+                              last_requested_block = block_number;
+                    }
+
                     if (data->trace)
                          fprintf(stderr, "received ACK <block: %ld>\n",
                                  block_number);
--- a/tftpd.c
+++ b/tftpd.c
@@ -65,6 +65,7 @@
 
 int tftpd_daemon = 0;           /* By default we are started by inetd */
 int tftpd_daemon_no_fork = 0;   /* For who want a false daemon mode */
+int tftpd_prevent_sas = 0;      /* For who don't want the sorcerer's apprentice syndrome */
 short tftpd_port = 69;          /* Port atftpd listen to */
 char tftpd_addr[MAXLEN] = "";   /* IP address atftpd binds to */
 
@@ -927,6 +928,7 @@
           { "mtftp", 1, NULL, OPT_MTFTP },
           { "mtftp-port", 1, NULL, OPT_MTFTP_PORT },
 #endif
+          { "prevent-sas", 0, NULL, 'X' },
           { "no-source-port-checking", 0, NULL, OPT_PORT_CHECK },
           { "mcast-switch-client", 0, NULL, OPT_MCAST_SWITCH },
           { "version", 0, NULL, 'V' },
@@ -996,6 +998,9 @@
           case 'N':
                tftpd_daemon_no_fork = 1;
                break;
+          case 'X':
+               tftpd_prevent_sas = 1;
+               break;
           case 'U':
                tmp = strtok(optarg, ".");
                if (tmp != NULL)
@@ -1228,6 +1233,7 @@
             "  --listen-local             : force listen on local network address\n"
             "  --daemon                   : run atftpd standalone (no inetd)\n"
             "  --no-fork                  : run as a daemon, don't fork\n"
+            "  --prevent-sas              : prevent Sorcerer's Apprentice Syndrome\n"
             "  --user <user[.group]>      : default is nobody\n"
             "  --group <group>            : default is nogroup\n"
             "  --port <port>              : port on which atftp listen\n"
--- a/tftpd_file.c
+++ b/tftpd_file.c
@@ -55,6 +55,7 @@
 extern char directory[MAXLEN];
 /* read only except for the main thread */
 extern int tftpd_cancel;
+extern int tftpd_prevent_sas;
 
 #ifdef HAVE_PCRE
 extern tftpd_pcre_self_t *pcre_top;
@@ -407,6 +408,7 @@
      int timeout_state = state;
      int result;
      long block_number = 0;
+     long last_requested_block = -1;
      long last_block = -1;
      int data_size;
      struct sockaddr_storage *sa = &data->client_info->client;
@@ -733,6 +735,7 @@
                     state = S_SEND_OACK;
                else
                     state = S_SEND_DATA;
+               last_requested_block = 0;
                break;
           case S_SEND_OACK:
                timeout_state = state;
@@ -818,6 +821,10 @@
                                           sockaddr_get_port(
                                                &client_info->client));
                                    sa = &client_info->client;
+
+                                   /* rewind the last_requested_block counter */
+                                   last_requested_block = -1;
+
                                    state = S_SEND_OACK;
                                    break;
                               }
@@ -903,6 +910,28 @@
                     if (data->trace)
                          logger(LOG_DEBUG, "received ACK <block: %ld>",
                                 block_number);
+
+                    /* if turned on, check whether the block request isn't already fulfilled */
+                    if (tftpd_prevent_sas) {
+                         /* multicast, block numbers could contain gaps */
+                         if (multicast) {
+                              if (last_requested_block >= block_number) {
+                                   if (data->trace)
+                                        logger(LOG_INFO, "received duplicated ACK <block: %d >= %d>", last_requested_block, block_number);
+                                   break;
+                              } else
+                                   last_requested_block = block_number;
+                              /* unicast, blocks should be requested one after another */
+                         } else {
+                              if (last_requested_block != block_number) {
+                                   if (data->trace)
+                                        logger(LOG_INFO, "received out of order ACK <block: %d != %d>", last_requested_block, block_number);
+                                   break;
+                              } else
+                                   last_requested_block = block_number;
+                         }
+                    }
+
                     if ((last_block != -1) && (block_number > last_block))
                     {
                          state = S_END;
@@ -1001,6 +1030,8 @@
                          /* nedd to send an oack to that client */
                          state = S_SEND_OACK;                
                          fseek(fp, 0, SEEK_SET);
+			 /* reset the last block received counter */
+			 last_requested_block = -1;
                     }
                     else
                     {
