Description: Fix MTFTP support for atftp
 This patch makes MTFTP work again, at least to some extend.
 A patch provided in Debian bug 580473#15 was helpful to understand
 some of the development history of the code and might be
 considered in further iterations/improvements again.
 Neither MTFTP nor its use today are completely clear to me.
Author: Author: Andreas B. Mundt <andi@debian.org>
Forwarded: https://sourceforge.net/p/atftp/
Last-Update: 2022-09-04
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/

--- a/tftpd_mtftp.c
+++ b/tftpd_mtftp.c
@@ -206,24 +206,31 @@
                       thread->client_port, filename, line);
                fclose(thread->fp);
                continue;
-          } 
+          }
           /* verify IP is valid */
           memset(&hints, 0, sizeof(hints));
           hints.ai_socktype = SOCK_DGRAM;
-          if (!getaddrinfo(thread->mcast_ip, thread->client_port,
-                           &hints, &addrinfo) &&
-              !sockaddr_set_addrinfo(&thread->sa_mcast, addrinfo))
+          hints.ai_flags = AI_NUMERICHOST;
+          if (getaddrinfo(thread->mcast_ip, NULL, &hints, &addrinfo) ||
+              sockaddr_set_addrinfo(&thread->sa_mcast, addrinfo))
           {
-               thread->mcast_port = sockaddr_get_port(&thread->sa_mcast);
-               freeaddrinfo(addrinfo);
-               if (!sockaddr_is_multicast(&thread->sa_mcast))
-               {
-                    logger(LOG_WARNING, "mtftp: bad multicast address %s\n",
-                           thread->mcast_ip);
-                    fclose(thread->fp);
-                    continue;
-               }
+               logger(LOG_ERR, "bad address %s\n", thread->mcastaddr);
+               fclose(thread->fp);
+               continue;
           }
+          freeaddrinfo(addrinfo);
+          sockaddr_set_port(&thread->sa_mcast, thread->mcast_port);
+          thread->mcast_port = sockaddr_get_port(&thread->sa_mcast);
+
+          /* verify address is multicast */
+          if (!sockaddr_is_multicast(&thread->sa_mcast))
+          {
+               logger(LOG_WARNING, "mtftp: bad multicast address %s\n",
+                      thread->mcast_ip);
+               fclose(thread->fp);
+               continue;
+          }
+
           /* verify IP/port is unique */
           if (tftpd_mtftp_unique(data, thread->file_name, thread->mcast_ip, thread->client_port))
           {
@@ -428,10 +435,11 @@
                }
                else
                {
-                    logger(LOG_NOTICE, "Serving %s to %s:%d", filename,
-                           sockaddr_print_addr(&sa, addr_str, sizeof(addr_str)));
                     if (data->trace)
                          logger(LOG_DEBUG, "received RRQ <%s>", string);
+                    logger(LOG_NOTICE, "serving %s to %s:%d", filename,
+                           sockaddr_print_addr(&sa, addr_str, sizeof(addr_str)),
+                           sockaddr_get_port(&sa));
                }
                /* validity check, only octet mode supported */
                if (strcasecmp(data->tftp_options[OPT_MODE].value, "octet") != 0)
@@ -478,10 +486,10 @@
                /* configure multicast socket */
                sockaddr_get_mreq(&thread->sa_mcast, &thread->mcastaddr);
                if (thread->sa_mcast.ss_family == AF_INET)
-                    setsockopt(thread->sockfd, IPPROTO_IP, IP_MULTICAST_TTL,
+                    setsockopt(thread->mcast_sockfd, IPPROTO_IP, IP_MULTICAST_TTL,
                                &data->mcast_ttl, sizeof(data->mcast_ttl));
                else
-                    setsockopt(thread->sockfd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
+                    setsockopt(thread->mcast_sockfd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
                                &data->mcast_ttl, sizeof(data->mcast_ttl));
 
                /* give server thread access to mtftp options */
@@ -565,8 +573,12 @@
                /* send data to unicast address */
                tftp_send_data(sockfd, sa, block_number + 1,
                               data_size, data->data_buffer);
+               /* in addition, send data to multicast address, so that listening
+                  clients do not miss the first block */
+               tftp_send_data(sockfd, &data->sa_mcast, block_number + 1,
+                              data_size, data->data_buffer);
                if (data->mtftp_data->trace)
-                    logger(LOG_DEBUG, "sent DATA <block: %ld, size %d>",
+                    logger(LOG_DEBUG, "sent DATA <block: %ld, size %d> to multi- and unicast address",
                            block_number + 1, data_size - 4);
                state = S_WAIT_PACKET;
                break;
--- a/tftp_mtftp.c
+++ b/tftp_mtftp.c
@@ -119,7 +119,7 @@
      FILE *fp = NULL;           /* the local file pointer */
      int number_of_timeout = 0;
      int timeout = 0;
-
+     long last_ackd_block = -1;
      struct sockaddr_storage sa_mcast_group;
      int mcast_sockfd = 0;
      struct sockaddr_storage sa_mcast;
@@ -175,24 +175,23 @@
      /* if valid, update s_inn structure */
      memset(&hints, 0, sizeof(hints));
      hints.ai_socktype = SOCK_DGRAM;
-     if (!getaddrinfo(data->mtftp_mcast_ip, NULL, &hints, &addrinfo) &&
-         !sockaddr_set_addrinfo(&sa_mcast_group, addrinfo))
-     {
-          freeaddrinfo(addrinfo);
-          if (!sockaddr_is_multicast(&sa_mcast_group))
-	  {
-	       fprintf(stderr,
-		       "mtftp: bad multicast address %s\n",
-		       data->mtftp_mcast_ip);
-	       exit(1);
-	  }
-     } 
-     else
+     hints.ai_flags = AI_NUMERICHOST;
+     if (getaddrinfo(data->mtftp_mcast_ip, NULL, &hints, &addrinfo) ||
+         sockaddr_set_addrinfo(&sa_mcast_group, addrinfo))
+     {
+          fprintf(stderr,
+                  "mtftp: bad address %s\n", data->mtftp_mcast_ip);
+          exit(1);
+     }
+     freeaddrinfo(addrinfo);
+
+     if (!sockaddr_is_multicast(&sa_mcast_group))
      {
-	  fprintf(stderr, "atftp: bad multicast address %s",
+	  fprintf(stderr, "atftp: bad multicast address %s\n",
 		  data->mtftp_mcast_ip);
 	  exit(1);
      }
+     
      /* we need to open a new socket for multicast */
      if ((mcast_sockfd = socket(AF_INET, SOCK_DGRAM, 0))<0)
      {
@@ -201,7 +200,7 @@
      }                   
      memset(&sa_mcast, 0, sizeof(sa_mcast));
      sa_mcast.ss_family = sa_mcast_group.ss_family;
-     sockaddr_set_port(&sa, data->mtftp_client_port);
+     sockaddr_set_port(&sa_mcast, data->mtftp_client_port);
                          
      if (bind(mcast_sockfd, (struct sockaddr *)&sa_mcast,
 	      sizeof(sa_mcast)) < 0)
@@ -315,9 +314,14 @@
                //tftp_find_bitmap_hole(prev_bitmap_hole, file_bitmap);
                //block_number = prev_bitmap_hole;
 
-               if (data->trace)
-                    fprintf(stderr, "sent ACK <block: %ld>\n", block_number);
-               tftp_send_ack(sockfd, &sa, block_number);
+               /* only send a single ack for the first block, although we get
+                  a unicast and a multicast datagram: */
+               if (last_ackd_block != block_number) {
+                    if (data->trace)
+                         fprintf(stderr, "sent ACK <block: %ld>\n", block_number);
+                    tftp_send_ack(sockfd, &sa, block_number);
+                    last_ackd_block = block_number;
+               }
                /* if we just ACK the last block we are done */
                if (block_number == last_block_number)
                     state = S_END;
